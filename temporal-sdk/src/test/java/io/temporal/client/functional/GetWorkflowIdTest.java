package io.temporal.client.functional;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import io.temporal.client.WorkflowOptions;
import io.temporal.client.WorkflowStub;
import io.temporal.internal.Issue;
import io.temporal.testing.internal.SDKTestWorkflowRule;
import io.temporal.workflow.shared.TestWorkflows;
import org.junit.Rule;
import org.junit.Test;

/**
 * Test cases specifically covering the smart logic use cases of getWorkflowId() method.
 *
 *   getWorkflowId()
 *   ├── Is workflow started? (getExecution() != null)
 *   │   ├── YES → Return execution.getWorkflowId() [Case 1]
 *   │   └── NO → Continue to next check
 *   ├── Has explicit workflow ID? (options.getWorkflowId() != null && !isEmpty())
 *   │   ├── YES → Return options.getWorkflowId() [Case 2]
 *   │   └── NO → Continue to next check
 *   ├── Is workflow ID null or empty?
 *       ├── YES → Throw IllegalStateException [Cases 3 & 4]
 *       └── NO → Should not reach here
 */

@Issue("https://github.com/temporalio/sdk-java/issues/2651")
public class GetWorkflowIdTest {
  @Rule
  public SDKTestWorkflowRule testWorkflowRule =
      SDKTestWorkflowRule.newBuilder()
          .setWorkflowTypes(TestWorkflowImpl.class, TestSignaledWorkflowImpl.class)
          .build();

  // ==========  Case 1: Workflow is started - returns ID from execution ==========

  @Test
  public void testSmartLogic_WorkflowStarted_ReturnsIdFromExecution() {
    // Test with explicit workflow ID
    String explicitWorkflowId = "started-workflow-explicit-id";
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(explicitWorkflowId)
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Start the workflow
    workflowStub.start();

    // Should return ID from execution ( Case 1)
    assertEquals(
        "Should return workflow ID from execution after start",
        explicitWorkflowId,
        workflowStub.getWorkflowId());
    assertEquals(
        "Should match getExecution().getWorkflowId()",
        workflowStub.getExecution().getWorkflowId(),
        workflowStub.getWorkflowId());
  }

  @Test
  public void testSmartLogic_WorkflowStarted_AutoGeneratedId_ReturnsIdFromExecution() {
    // Test with auto-generated workflow ID
    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule.newWorkflowStub(TestWorkflows.NoArgsWorkflow.class);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Start the workflow (ID will be auto-generated)
    workflowStub.start();

    // Should return ID from execution ( Case 1)
    String workflowId = workflowStub.getWorkflowId();
    assertNotNull("Should return workflow ID from execution after start", workflowId);
    assertTrue("Generated workflow ID should not be empty", !workflowId.isEmpty());
    assertEquals(
        "Should match getExecution().getWorkflowId()",
        workflowStub.getExecution().getWorkflowId(),
        workflowStub.getWorkflowId());
  }

  @Test
  public void testSmartLogic_WorkflowStartedWithSignalWithStart_ReturnsIdFromExecution() {
    String explicitWorkflowId = "signal-with-start-workflow-id";
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(explicitWorkflowId)
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.TestSignaledWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.TestSignaledWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Start with signalWithStart
    workflowStub.signalWithStart("signal", new String[] {"arg"}, new String[] {});

    // Should return ID from execution ( Case 1)
    assertEquals(
        "Should return workflow ID from execution after signalWithStart",
        explicitWorkflowId,
        workflowStub.getWorkflowId());
    assertEquals(
        "Should match getExecution().getWorkflowId()",
        workflowStub.getExecution().getWorkflowId(),
        workflowStub.getWorkflowId());
  }

  @Test
  public void testSmartLogic_ExistingExecutionStub_ReturnsIdFromExecution() {
    // Start a workflow first
    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule.newWorkflowStub(TestWorkflows.NoArgsWorkflow.class);
    WorkflowStub originalStub = WorkflowStub.fromTyped(workflow);
    originalStub.start();

    String workflowId = originalStub.getExecution().getWorkflowId();

    // Create a new stub bound to the existing execution
    WorkflowStub existingStub =
        testWorkflowRule
            .getWorkflowClient()
            .newUntypedWorkflowStub(originalStub.getExecution(), originalStub.getWorkflowType());

    // Should return ID from execution ( Case 1)
    assertEquals(
        "Should return workflow ID from existing execution",
        workflowId,
        existingStub.getWorkflowId());
  }

  // ==========  Case 2: Not started but has explicit workflow ID ==========

  @Test
  public void testSmartLogic_NotStarted_ExplicitId_ReturnsExplicitId() {
    String explicitWorkflowId = "explicit-workflow-id-before-start";
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(explicitWorkflowId)
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Should return explicit ID before start ( Case 2)
    assertEquals(
        "Should return explicit workflow ID before start",
        explicitWorkflowId,
        workflowStub.getWorkflowId());
  }

  @Test
  public void testSmartLogic_NotStarted_ExplicitId_ConsistencyAfterStart() {
    String explicitWorkflowId = "consistency-test-explicit-id";
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(explicitWorkflowId)
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Before start - should return explicit ID ( Case 2)
    assertEquals(
        "Should return explicit workflow ID before start",
        explicitWorkflowId,
        workflowStub.getWorkflowId());

    // Start the workflow
    workflowStub.start();

    // After start - should still return same ID ( Case 1)
    assertEquals(
        "Should return same workflow ID after start",
        explicitWorkflowId,
        workflowStub.getWorkflowId());
  }

  @Test
  public void testSmartLogic_NotStarted_ExplicitId_SpecialCharacters() {
    // Test with special characters in workflow ID
    String explicitWorkflowId = "workflow-id_with.special-chars123";
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(explicitWorkflowId)
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Should return explicit ID with special characters ( Case 2)
    assertEquals(
        "Should return explicit workflow ID with special characters",
        explicitWorkflowId,
        workflowStub.getWorkflowId());
  }

  // ==========  Case 3: No explicit workflow ID - throws IllegalStateException

  @Test
  public void testSmartLogic_NotStarted_NoExplicitId_ThrowsException() {
    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule.newWorkflowStub(TestWorkflows.NoArgsWorkflow.class);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Should throw exception when no explicit ID ( Case 3)
    try {
      workflowStub.getWorkflowId();
      fail("Should have thrown IllegalStateException for no explicit workflow ID");
    } catch (IllegalStateException e) {
      assertTrue(
          "Exception should mention workflow ID determination",
          e.getMessage().contains("Cannot determine workflow ID"));
      assertTrue(
          "Exception should mention explicit workflow ID requirement",
          e.getMessage().contains("no explicit workflow ID is set"));
    }
  }

  @Test
  public void testSmartLogic_NotStarted_NullWorkflowId_ThrowsException() {
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(null) // Explicitly set to null
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Should throw exception when workflow ID is null ( Case 3)
    try {
      workflowStub.getWorkflowId();
      fail("Should have thrown IllegalStateException for null workflow ID");
    } catch (IllegalStateException e) {
      assertTrue(
          "Exception should mention workflow ID determination",
          e.getMessage().contains("Cannot determine workflow ID"));
    }
  }

  @Test
  public void testSmartLogic_NotStarted_NoExplicitId_WorksAfterStart() {
    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule.newWorkflowStub(TestWorkflows.NoArgsWorkflow.class);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Should throw exception before start ( Case 3)
    try {
      workflowStub.getWorkflowId();
      fail("Should have thrown IllegalStateException before start");
    } catch (IllegalStateException e) {
      // Expected
    }

    // Start the workflow
    workflowStub.start();

    // Should work after start ( Case 1)
    String workflowId = workflowStub.getWorkflowId();
    assertNotNull("Should return workflow ID after start", workflowId);
    assertTrue("Generated workflow ID should not be empty", !workflowId.isEmpty());
  }

  // ==========  Case 4: Empty string handling ==========

  @Test
  public void testSmartLogic_NotStarted_EmptyWorkflowId_ThrowsException() {
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId("") // Empty string
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Should throw exception when workflow ID is empty string ( Case 4)
    try {
      workflowStub.getWorkflowId();
      fail("Should have thrown IllegalStateException for empty workflow ID");
    } catch (IllegalStateException e) {
      assertTrue(
          "Exception should mention workflow ID determination",
          e.getMessage().contains("Cannot determine workflow ID"));
    }
  }

  @Test
  public void testSmartLogic_NotStarted_WhitespaceWorkflowId_ReturnsWhitespace() {
    // Whitespace is considered a valid workflow ID (not empty)
    String whitespaceWorkflowId = "   ";
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(whitespaceWorkflowId)
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Should return whitespace ID ( Case 2 - has explicit ID)
    assertEquals(
        "Should return whitespace workflow ID", whitespaceWorkflowId, workflowStub.getWorkflowId());
  }

  @Test
  public void testSmartLogic_EmptyString_WorksAfterStart() {
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId("") // Empty string
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Should throw exception before start ( Case 4)
    try {
      workflowStub.getWorkflowId();
      fail("Should have thrown IllegalStateException for empty workflow ID");
    } catch (IllegalStateException e) {
      // Expected
    }

    // Start the workflow
    workflowStub.start();

    // Should work after start with the empty string ID ( Case 1)
    String workflowId = workflowStub.getWorkflowId();
    assertNotNull("Should return workflow ID after start", workflowId);
    assertEquals("Should return empty string workflow ID", "", workflowId);
  }

  // ========== Edge Cases and Transitions Between  Cases ==========

  @Test
  public void testSmartLogic_TransitionFromCase2ToCase1() {
    // Test transition from Case 2 (explicit ID before start) to Case 1 (ID from execution after
    // start)
    String explicitWorkflowId = "transition-test-id";
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(explicitWorkflowId)
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Before start:  Case 2
    assertEquals(
        "Should use Case 2 logic before start", explicitWorkflowId, workflowStub.getWorkflowId());

    // Start the workflow
    workflowStub.start();

    // After start:  Case 1 (but should return same ID)
    assertEquals(
        "Should use Case 1 logic after start", explicitWorkflowId, workflowStub.getWorkflowId());
    assertEquals(
        "Should match execution ID",
        workflowStub.getExecution().getWorkflowId(),
        workflowStub.getWorkflowId());
  }

  @Test
  public void testSmartLogic_MultipleCallsConsistency() {
    String explicitWorkflowId = "consistency-multiple-calls";
    WorkflowOptions options =
        WorkflowOptions.newBuilder()
            .setWorkflowId(explicitWorkflowId)
            .setTaskQueue(testWorkflowRule.getTaskQueue())
            .build();

    TestWorkflows.NoArgsWorkflow workflow =
        testWorkflowRule
            .getWorkflowClient()
            .newWorkflowStub(TestWorkflows.NoArgsWorkflow.class, options);
    WorkflowStub workflowStub = WorkflowStub.fromTyped(workflow);

    // Multiple calls before start should return same result ( Case 2)
    assertEquals(explicitWorkflowId, workflowStub.getWorkflowId());
    assertEquals(explicitWorkflowId, workflowStub.getWorkflowId());
    assertEquals(explicitWorkflowId, workflowStub.getWorkflowId());

    // Start the workflow
    workflowStub.start();

    // Multiple calls after start should return same result ( Case 1)
    assertEquals(explicitWorkflowId, workflowStub.getWorkflowId());
    assertEquals(explicitWorkflowId, workflowStub.getWorkflowId());
    assertEquals(explicitWorkflowId, workflowStub.getWorkflowId());
  }

  public static class TestWorkflowImpl implements TestWorkflows.NoArgsWorkflow {
    @Override
    public void execute() {
      // Simple workflow that completes immediately
    }
  }

  public static class TestSignaledWorkflowImpl implements TestWorkflows.TestSignaledWorkflow {
    @Override
    public String execute() {
      return "done";
    }

    @Override
    public void signal(String arg) {
      // Signal handler
    }
  }
}
